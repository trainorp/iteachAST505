Recycle <- function (...) 
{
  lst <- list(...)
  maxdim <- max(lengths(lst))
  res <- lapply(lst, rep, length.out = maxdim)
  attr(res, "maxdim") <- maxdim
  return(res)
}

BinomCI <- function (x, n, conf.level = 0.95, sides = c("two.sided", 
                                             "left", "right"), method = c("wilson", 
                                                                          "wald", "agresti-coull", "jeffreys", "modified wilson", 
                                                                          "wilsoncc", "modified jeffreys", "clopper-pearson", 
                                                                          "arcsine", "logit", "witting", "pratt"), 
          rand = 123) 
{
  if (missing(method)) 
    method <- "wilson"
  if (missing(sides)) 
    sides <- "two.sided"
  iBinomCI <- function(x, n, conf.level = 0.95, sides = c("two.sided", 
                                                          "left", "right"), method = c("wilson", 
                                                                                       "wilsoncc", "wald", "agresti-coull", 
                                                                                       "jeffreys", "modified wilson", "modified jeffreys", 
                                                                                       "clopper-pearson", "arcsine", "logit", 
                                                                                       "witting", "pratt"), rand = 123) {
    if (length(x) != 1) 
      stop("'x' has to be of length 1 (number of successes)")
    if (length(n) != 1) 
      stop("'n' has to be of length 1 (number of trials)")
    if (length(conf.level) != 1) 
      stop("'conf.level' has to be of length 1 (confidence level)")
    if (conf.level < 0.5 | conf.level > 1) 
      stop("'conf.level' has to be in [0.5, 1]")
    sides <- match.arg(sides, choices = c("two.sided", 
                                          "left", "right"), several.ok = FALSE)
    if (sides != "two.sided") 
      conf.level <- 1 - 2 * (1 - conf.level)
    alpha <- 1 - conf.level
    kappa <- qnorm(1 - alpha/2)
    p.hat <- x/n
    q.hat <- 1 - p.hat
    switch(match.arg(arg = method, choices = c("wilson", 
                                               "wald", "wilsoncc", "agresti-coull", 
                                               "jeffreys", "modified wilson", "modified jeffreys", 
                                               "clopper-pearson", "arcsine", "logit", 
                                               "witting", "pratt")), wald = {
                                                 est <- p.hat
                                                 term2 <- kappa * sqrt(p.hat * q.hat)/sqrt(n)
                                                 CI.lower <- max(0, p.hat - term2)
                                                 CI.upper <- min(1, p.hat + term2)
                                               }, wilson = {
                                                 est <- p.hat
                                                 term1 <- (x + kappa^2/2)/(n + kappa^2)
                                                 term2 <- kappa * sqrt(n)/(n + kappa^2) * sqrt(p.hat * 
                                                                                                 q.hat + kappa^2/(4 * n))
                                                 CI.lower <- max(0, term1 - term2)
                                                 CI.upper <- min(1, term1 + term2)
                                               }, wilsoncc = {
                                                 est <- p.hat
                                                 lci <- (2 * x + kappa^2 - 1 - kappa * sqrt(kappa^2 - 
                                                                                              2 - 1/n + 4 * p.hat * (n * q.hat + 1)))/(2 * 
                                                                                                                                         (n + kappa^2))
                                                 uci <- (2 * x + kappa^2 + 1 + kappa * sqrt(kappa^2 + 
                                                                                              2 - 1/n + 4 * p.hat * (n * q.hat - 1)))/(2 * 
                                                                                                                                         (n + kappa^2))
                                                 CI.lower <- max(0, lci)
                                                 CI.upper <- min(1, uci)
                                               }, `agresti-coull` = {
                                                 x.tilde <- x + kappa^2/2
                                                 n.tilde <- n + kappa^2
                                                 p.tilde <- x.tilde/n.tilde
                                                 q.tilde <- 1 - p.tilde
                                                 est <- p.tilde
                                                 term2 <- kappa * sqrt(p.tilde * q.tilde)/sqrt(n.tilde)
                                                 CI.lower <- max(0, p.tilde - term2)
                                                 CI.upper <- min(1, p.tilde + term2)
                                               }, jeffreys = {
                                                 est <- p.hat
                                                 if (x == 0) CI.lower <- 0 else CI.lower <- qbeta(alpha/2, 
                                                                                                  x + 0.5, n - x + 0.5)
                                                 if (x == n) CI.upper <- 1 else CI.upper <- qbeta(1 - 
                                                                                                    alpha/2, x + 0.5, n - x + 0.5)
                                               }, `modified wilson` = {
                                                 est <- p.hat
                                                 term1 <- (x + kappa^2/2)/(n + kappa^2)
                                                 term2 <- kappa * sqrt(n)/(n + kappa^2) * sqrt(p.hat * 
                                                                                                 q.hat + kappa^2/(4 * n))
                                                 if ((n <= 50 & x %in% c(1, 2)) | (n >= 51 & x %in% 
                                                                                   c(1:3))) CI.lower <- 0.5 * qchisq(alpha, 2 * 
                                                                                                                       x)/n else CI.lower <- max(0, term1 - term2)
                                                 if ((n <= 50 & x %in% c(n - 1, n - 2)) | (n >= 51 & 
                                                                                           x %in% c(n - (1:3)))) CI.upper <- 1 - 0.5 * qchisq(alpha, 
                                                                                                                                              2 * (n - x))/n else CI.upper <- min(1, term1 + 
                                                                                                                                                                                    term2)
                                               }, `modified jeffreys` = {
                                                 est <- p.hat
                                                 if (x == n) CI.lower <- (alpha/2)^(1/n) else {
                                                   if (x <= 1) CI.lower <- 0 else CI.lower <- qbeta(alpha/2, 
                                                                                                    x + 0.5, n - x + 0.5)
                                                 }
                                                 if (x == 0) CI.upper <- 1 - (alpha/2)^(1/n) else {
                                                   if (x >= n - 1) CI.upper <- 1 else CI.upper <- qbeta(1 - 
                                                                                                          alpha/2, x + 0.5, n - x + 0.5)
                                                 }
                                               }, `clopper-pearson` = {
                                                 est <- p.hat
                                                 CI.lower <- qbeta(alpha/2, x, n - x + 1)
                                                 CI.upper <- qbeta(1 - alpha/2, x + 1, n - x)
                                               }, arcsine = {
                                                 p.tilde <- (x + 0.375)/(n + 0.75)
                                                 est <- p.tilde
                                                 CI.lower <- sin(asin(sqrt(p.tilde)) - 0.5 * kappa/sqrt(n))^2
                                                 CI.upper <- sin(asin(sqrt(p.tilde)) + 0.5 * kappa/sqrt(n))^2
                                               }, logit = {
                                                 est <- p.hat
                                                 lambda.hat <- log(x/(n - x))
                                                 V.hat <- n/(x * (n - x))
                                                 lambda.lower <- lambda.hat - kappa * sqrt(V.hat)
                                                 lambda.upper <- lambda.hat + kappa * sqrt(V.hat)
                                                 CI.lower <- exp(lambda.lower)/(1 + exp(lambda.lower))
                                                 CI.upper <- exp(lambda.upper)/(1 + exp(lambda.upper))
                                               }, witting = {
                                                 set.seed(rand)
                                                 x.tilde <- x + runif(1, min = 0, max = 1)
                                                 pbinom.abscont <- function(q, size, prob) {
                                                   v <- trunc(q)
                                                   term1 <- pbinom(v - 1, size = size, prob = prob)
                                                   term2 <- (q - v) * dbinom(v, size = size, prob = prob)
                                                   return(term1 + term2)
                                                 }
                                                 qbinom.abscont <- function(p, size, x) {
                                                   fun <- function(prob, size, x, p) {
                                                     pbinom.abscont(x, size, prob) - p
                                                   }
                                                   uniroot(fun, interval = c(0, 1), size = size, 
                                                           x = x, p = p)$root
                                                 }
                                                 est <- p.hat
                                                 CI.lower <- qbinom.abscont(1 - alpha, size = n, x = x.tilde)
                                                 CI.upper <- qbinom.abscont(alpha, size = n, x = x.tilde)
                                               }, pratt = {
                                                 est <- p.hat
                                                 if (x == 0) {
                                                   CI.lower <- 0
                                                   CI.upper <- 1 - alpha^(1/n)
                                                 } else if (x == 1) {
                                                   CI.lower <- 1 - (1 - alpha/2)^(1/n)
                                                   CI.upper <- 1 - (alpha/2)^(1/n)
                                                 } else if (x == (n - 1)) {
                                                   CI.lower <- (alpha/2)^(1/n)
                                                   CI.upper <- (1 - alpha/2)^(1/n)
                                                 } else if (x == n) {
                                                   CI.lower <- alpha^(1/n)
                                                   CI.upper <- 1
                                                 } else {
                                                   z <- qnorm(1 - alpha/2)
                                                   A <- ((x + 1)/(n - x))^2
                                                   B <- 81 * (x + 1) * (n - x) - 9 * n - 8
                                                   C <- (0 - 3) * z * sqrt(9 * (x + 1) * (n - x) * 
                                                                             (9 * n + 5 - z^2) + n + 1)
                                                   D <- 81 * (x + 1)^2 - 9 * (x + 1) * (2 + z^2) + 
                                                     1
                                                   E <- 1 + A * ((B + C)/D)^3
                                                   CI.upper <- 1/E
                                                   A <- (x/(n - x - 1))^2
                                                   B <- 81 * x * (n - x - 1) - 9 * n - 8
                                                   C <- 3 * z * sqrt(9 * x * (n - x - 1) * (9 * 
                                                                                              n + 5 - z^2) + n + 1)
                                                   D <- 81 * x^2 - 9 * x * (2 + z^2) + 1
                                                   E <- 1 + A * ((B + C)/D)^3
                                                   CI.lower <- 1/E
                                                 }
                                               })
    ci <- c(est = est, lwr.ci = max(0, CI.lower), upr.ci = min(1, 
                                                               CI.upper))
    if (sides == "left") 
      ci[3] <- 1
    else if (sides == "right") 
      ci[2] <- 0
    return(ci)
  }
  lst <- list(x = x, n = n, conf.level = conf.level, sides = sides, 
              method = method, rand = rand)
  maxdim <- max(unlist(lapply(lst, length)))
  lgp <- lapply(lst, rep, length.out = maxdim)
  lgn <- Recycle(x = if (is.null(names(x))) 
    paste("x", seq_along(x), sep = ".")
    else names(x), n = if (is.null(names(n))) 
      paste("n", seq_along(n), sep = ".")
    else names(n), conf.level = conf.level, sides = sides, method = method)
  xn <- apply(as.data.frame(lgn[sapply(lgn, function(x) length(unique(x)) != 
                                         1)]), 1, paste, collapse = ":")
  res <- t(sapply(1:maxdim, function(i) iBinomCI(x = lgp$x[i], 
                                                 n = lgp$n[i], conf.level = lgp$conf.level[i], sides = lgp$sides[i], 
                                                 method = lgp$method[i], rand = lgp$rand[i])))
  colnames(res)[1] <- c("est")
  rownames(res) <- xn
  return(res)
}
                  
